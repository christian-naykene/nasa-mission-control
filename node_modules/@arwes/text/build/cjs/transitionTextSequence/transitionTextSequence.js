"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transitionTextSequence = void 0;
const motion_1 = require("motion");
const animated_1 = require("@arwes/animated");
const index_1 = require("../internal/walkTextNodes/index");
const index_2 = require("../internal/setTextNodesContent/index");
const transitionTextSequence = (props) => {
    const { rootElement, contentElement, duration, easing = 'linear', isEntering = true, hideOnExited = true, hideOnEntered } = props;
    // If no valid elements are provided, return an void animation for type safety.
    if (!rootElement || !contentElement) {
        return {
            isPending: () => false,
            cancel: () => { }
        };
    }
    const cloneElement = contentElement.cloneNode(true);
    Object.assign(cloneElement.style, {
        position: 'absolute',
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        visibility: 'visible',
        opacity: 1
    });
    const blinkElement = document.createElement('span');
    blinkElement.classList.add('arwes-text__blink');
    blinkElement.innerHTML = '&#9614;';
    Object.assign(blinkElement.style, {
        position: 'relative',
        display: 'inline-block',
        width: 0,
        height: 0,
        lineHeight: '0',
        color: 'inherit'
    });
    const textNodes = [];
    const texts = [];
    (0, index_1.walkTextNodes)(cloneElement, child => {
        textNodes.push(child);
        texts.push(child.textContent || '');
        if (isEntering) {
            child.textContent = '';
        }
    });
    const length = texts.join('').length;
    rootElement.appendChild(cloneElement);
    cloneElement.appendChild(blinkElement);
    contentElement.style.visibility = 'hidden';
    const blinkAnimation = (0, motion_1.animate)(blinkElement, { color: ['transparent', 'inherit', 'transparent'] }, { duration: 0.1, easing: 'steps(2, end)', repeat: Infinity });
    return (0, animated_1.createAnimation)({
        duration,
        easing,
        direction: isEntering ? 'normal' : 'reverse',
        onUpdate: progress => {
            const newLength = Math.round(progress * length);
            (0, index_2.setTextNodesContent)(textNodes, texts, newLength);
        },
        onComplete: () => {
            contentElement.style.visibility = (isEntering && hideOnEntered) || (!isEntering && hideOnExited)
                ? 'hidden'
                : 'visible';
            cloneElement.remove();
            blinkAnimation.cancel();
        },
        onCancel: () => {
            contentElement.style.visibility = '';
            cloneElement.remove();
            blinkAnimation.cancel();
        }
    });
};
exports.transitionTextSequence = transitionTextSequence;
