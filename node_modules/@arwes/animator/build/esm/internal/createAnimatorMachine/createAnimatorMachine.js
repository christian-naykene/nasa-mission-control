import { IS_BROWSER } from '@arwes/tools';
import { ANIMATOR_STATES as STATES, ANIMATOR_ACTIONS as ACTIONS } from "../../constants.js";
import { createAnimatorManager } from "../../internal/createAnimatorManager/index.js";
const createAnimatorMachine = (node, initialState) => {
    let state = initialState;
    const statesMap = {
        [STATES.exited]: {
            onActions: {
                [ACTIONS.enter]: STATES.entering,
                [ACTIONS.setup]: () => {
                    const settings = node.control.getSettings();
                    if (node.parent) {
                        const parentSettings = node.parent.control.getSettings();
                        switch (node.parent.state) {
                            case STATES.entering: {
                                if (parentSettings.combine || settings.merge) {
                                    node.parent.manager.enterChildren([node]);
                                }
                                break;
                            }
                            // If the parent has already entered, enter the incoming children whether
                            // they have "merge" setting or the parent is in "combine" setting.
                            case STATES.entered: {
                                node.parent.manager.enterChildren([node]);
                                break;
                            }
                        }
                    }
                    else {
                        const isActive = settings.active === undefined || settings.active;
                        if (isActive) {
                            return STATES.entering;
                        }
                    }
                }
            }
        },
        [STATES.entering]: {
            onEntry: {
                execute: () => {
                    const { combine } = node.control.getSettings();
                    const children = combine
                        ? Array.from(node.children)
                        : Array.from(node.children).filter(child => child.control.getSettings().merge);
                    node.manager.enterChildren(children);
                },
                schedule: () => {
                    const { duration } = node.control.getSettings();
                    return {
                        duration: (duration.delay + duration.enter) || 0,
                        action: ACTIONS.enterEnd
                    };
                }
            },
            onActions: {
                [ACTIONS.enterEnd]: STATES.entered,
                [ACTIONS.exit]: STATES.exiting,
                [ACTIONS.refresh]: () => {
                    const settings = node.control.getSettings();
                    const childrenExited = Array
                        .from(node.children)
                        .filter(child => child.state === STATES.exited);
                    if (settings.combine) {
                        node.manager.enterChildren(childrenExited);
                    }
                    else {
                        const childrenMerged = childrenExited
                            .filter(child => child.control.getSettings().merge);
                        node.manager.enterChildren(childrenMerged);
                    }
                }
            }
        },
        [STATES.entered]: {
            onEntry: {
                execute: () => {
                    const { combine } = node.control.getSettings();
                    if (combine) {
                        return;
                    }
                    const children = Array
                        .from(node.children)
                        .filter(child => !child.control.getSettings().merge);
                    node.manager.enterChildren(children);
                }
            },
            onActions: {
                [ACTIONS.exit]: STATES.exiting,
                [ACTIONS.refresh]: () => {
                    const childrenExited = Array
                        .from(node.children)
                        .filter(child => child.state === STATES.exited);
                    node.manager.enterChildren(childrenExited);
                }
            }
        },
        [STATES.exiting]: {
            onEntry: {
                execute: () => {
                    Array.from(node.children).forEach(child => {
                        if (child.state === STATES.entering || child.state === STATES.entered) {
                            child.send(ACTIONS.exit);
                        }
                        else if (child.state === STATES.exited) {
                            child.scheduler.stopAll();
                        }
                        // If the child is EXITING, it will go to EXITED soon.
                    });
                },
                schedule: () => ({
                    duration: node.control.getSettings().duration.exit || 0,
                    action: ACTIONS.exitEnd
                })
            },
            onActions: {
                [ACTIONS.exitEnd]: STATES.exited,
                [ACTIONS.enter]: STATES.entering
            }
        },
        '*': {
            onActions: {
                [ACTIONS.update]: () => {
                    var _a, _b;
                    const settings = node.control.getSettings();
                    if (settings.manager !== node.manager.name) {
                        (_b = (_a = node.manager).destroy) === null || _b === void 0 ? void 0 : _b.call(_a);
                        node.manager = createAnimatorManager(node, settings.manager);
                    }
                    if (!node.parent) {
                        const isActive = settings.active === true ||
                            settings.active === undefined;
                        if ((state === STATES.exited || state === STATES.exiting) && isActive) {
                            return STATES.entering;
                        }
                        else if ((state === STATES.entered || state === STATES.entering) && !isActive) {
                            return STATES.exiting;
                        }
                    }
                }
            }
        }
    };
    const transition = (newState) => {
        if (!newState || state === newState) {
            return;
        }
        state = newState;
        const { onEntry } = statesMap[state] || {};
        const { onTransition } = node.control.getSettings();
        node.scheduler.stopAll();
        if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.execute) {
            onEntry.execute();
        }
        if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.schedule) {
            const task = onEntry.schedule();
            node.scheduler.start(task.duration, () => send(task.action));
        }
        onTransition === null || onTransition === void 0 ? void 0 : onTransition(node);
        for (const subscriber of node.subscribers) {
            subscriber(node);
        }
    };
    const processAction = (procedure) => {
        if (procedure === undefined) {
            return;
        }
        if (typeof procedure === 'string') {
            transition(procedure);
        }
        else {
            const newState = procedure();
            if (newState) {
                transition(newState);
            }
        }
    };
    const getState = () => state;
    const send = (action) => {
        var _a, _b, _c, _d;
        // In non-browser environments, there are no transitions.
        if (!IS_BROWSER) {
            return;
        }
        processAction((_b = (_a = statesMap[state]) === null || _a === void 0 ? void 0 : _a.onActions) === null || _b === void 0 ? void 0 : _b[action]);
        processAction((_d = (_c = statesMap['*']) === null || _c === void 0 ? void 0 : _c.onActions) === null || _d === void 0 ? void 0 : _d[action]);
    };
    const machine = Object.freeze({ getState, send });
    return machine;
};
export { createAnimatorMachine };
