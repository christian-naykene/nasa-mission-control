"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAnimatorManager = void 0;
const constants_1 = require("../../constants");
const createAnimatorManagerParallel = node => {
    const getChildren = (childrenProvided) => {
        const children = (childrenProvided !== null && childrenProvided !== void 0 ? childrenProvided : Array.from(node.children));
        return children.filter(child => {
            const { condition } = child.control.getSettings();
            return condition ? condition(child) : true;
        });
    };
    const getDurationEnter = (childrenProvided) => {
        const children = getChildren(childrenProvided);
        return children.reduce((total, child) => Math.max(total, child.duration.enter), 0);
    };
    const enterChildren = (childrenProvided) => {
        const children = getChildren(childrenProvided);
        for (const child of children) {
            child.send(constants_1.ANIMATOR_ACTIONS.enter);
        }
    };
    return Object.freeze({
        name: constants_1.ANIMATOR_MANAGER_NAMES.parallel,
        getDurationEnter,
        enterChildren
    });
};
const createAnimatorManagerStagger = (node, name) => {
    let reservedUntilTime = 0;
    const getChildren = (childrenProvided) => {
        const children = (childrenProvided !== null && childrenProvided !== void 0 ? childrenProvided : Array.from(node.children));
        return children.filter(child => {
            const { condition } = child.control.getSettings();
            return condition ? condition(child) : true;
        });
    };
    const getDurationEnter = (childrenProvided) => {
        const children = getChildren(childrenProvided);
        if (!children.length) {
            return 0;
        }
        const { duration } = node.control.getSettings();
        const lastChild = children[children.length - 1];
        // TODO: If any of the children has a longer enter duration which surpasses
        // the accumulated + last child enter duration value, the total duration should
        // be greater.
        return (duration.stagger * (children.length - 1)) + lastChild.duration.enter;
    };
    const enterChildren = (childrenProvided) => {
        let children = getChildren(childrenProvided);
        const parentSettings = node.control.getSettings();
        const stagger = (parentSettings.duration.stagger || 0) * 1000; // seconds to ms
        if (name === constants_1.ANIMATOR_MANAGER_NAMES.staggerReverse) {
            children = children.reverse();
        }
        const now = Date.now();
        reservedUntilTime = Math.max(reservedUntilTime, now);
        for (const child of children) {
            const childSettings = child.control.getSettings();
            const offset = (childSettings.duration.offset || 0) * 1000; // seconds to ms
            reservedUntilTime = reservedUntilTime + offset;
            const time = (reservedUntilTime - now) / 1000; // ms to seconds
            const delay = childSettings.duration.delay || 0;
            reservedUntilTime = reservedUntilTime + stagger;
            child.scheduler.start(time + delay, () => child.send(constants_1.ANIMATOR_ACTIONS.enter));
        }
    };
    return Object.freeze({
        name,
        getDurationEnter,
        enterChildren
    });
};
const createAnimatorManagerSequence = (node, name) => {
    let reservedUntilTime = 0;
    const getChildren = (childrenProvided) => {
        const children = (childrenProvided !== null && childrenProvided !== void 0 ? childrenProvided : Array.from(node.children));
        return children.filter(child => {
            const { condition } = child.control.getSettings();
            return condition ? condition(child) : true;
        });
    };
    const getDurationEnter = (childrenProvided) => {
        const children = getChildren(childrenProvided);
        return children.reduce((total, child) => total + child.duration.enter, 0);
    };
    const enterChildren = (childrenProvided) => {
        let children = getChildren(childrenProvided);
        const now = Date.now();
        if (name === constants_1.ANIMATOR_MANAGER_NAMES.sequenceReverse) {
            children = children.reverse();
        }
        reservedUntilTime = Math.max(reservedUntilTime, now);
        for (const child of children) {
            const childSettings = child.control.getSettings();
            const offset = (childSettings.duration.offset || 0) * 1000; // seconds to ms
            const durationEnter = child.duration.enter * 1000; // seconds to ms
            reservedUntilTime = reservedUntilTime + offset;
            const time = (reservedUntilTime - now) / 1000; // ms to seconds
            const delay = childSettings.duration.delay || 0;
            reservedUntilTime += durationEnter;
            child.scheduler.start(time + delay, () => child.send(constants_1.ANIMATOR_ACTIONS.enter));
        }
    };
    return Object.freeze({
        name,
        getDurationEnter,
        enterChildren
    });
};
const createAnimatorManagerSwitch = node => {
    let nodeHiding;
    let nodeVisible;
    let nodeSubscriberUnsubscribe;
    const getDurationEnter = () => {
        if (nodeVisible) {
            return nodeVisible.duration.enter;
        }
        const nodeVisibleCurrent = Array.from(node.children).find(child => {
            const { condition } = child.control.getSettings();
            return condition ? condition(child) : true;
        });
        if (nodeVisibleCurrent) {
            return nodeVisibleCurrent.duration.enter;
        }
        return 0;
    };
    const enterChildren = () => {
        nodeSubscriberUnsubscribe === null || nodeSubscriberUnsubscribe === void 0 ? void 0 : nodeSubscriberUnsubscribe();
        nodeSubscriberUnsubscribe = undefined;
        const children = Array.from(node.children);
        const nodeVisibleNew = children.find(child => {
            const { condition } = child.control.getSettings();
            return condition ? condition(child) : true;
        });
        const onNextEnter = () => {
            if (nodeVisibleNew) {
                if (nodeVisibleNew === nodeVisible) {
                    nodeVisibleNew.send(constants_1.ANIMATOR_ACTIONS.enter);
                }
                else {
                    if (nodeVisible) {
                        nodeHiding = nodeVisible;
                        nodeSubscriberUnsubscribe = nodeHiding.subscribe(nodeHidingSubscribed => {
                            if (nodeHidingSubscribed.state === constants_1.ANIMATOR_STATES.exited) {
                                nodeSubscriberUnsubscribe === null || nodeSubscriberUnsubscribe === void 0 ? void 0 : nodeSubscriberUnsubscribe();
                                nodeSubscriberUnsubscribe = undefined;
                                nodeHiding = undefined;
                                nodeVisibleNew.send(constants_1.ANIMATOR_ACTIONS.enter);
                            }
                        });
                        nodeHiding === null || nodeHiding === void 0 ? void 0 : nodeHiding.send(constants_1.ANIMATOR_ACTIONS.exit);
                    }
                    else {
                        nodeVisibleNew.send(constants_1.ANIMATOR_ACTIONS.enter);
                        nodeHiding = undefined;
                    }
                    nodeVisible = nodeVisibleNew;
                }
            }
            else {
                nodeHiding = nodeVisible;
                nodeVisible = undefined;
            }
        };
        if (nodeHiding) {
            nodeSubscriberUnsubscribe = nodeHiding.subscribe(nodeHiding => {
                if (nodeHiding.state === constants_1.ANIMATOR_STATES.exited) {
                    onNextEnter();
                }
            });
        }
        else {
            onNextEnter();
        }
        children
            .filter(child => child !== nodeVisibleNew)
            .forEach(child => child.send(constants_1.ANIMATOR_ACTIONS.exit));
    };
    const destroy = () => {
        nodeHiding = undefined;
        nodeVisible = undefined;
        nodeSubscriberUnsubscribe === null || nodeSubscriberUnsubscribe === void 0 ? void 0 : nodeSubscriberUnsubscribe();
        nodeSubscriberUnsubscribe = undefined;
    };
    return Object.freeze({
        name: constants_1.ANIMATOR_MANAGER_NAMES.switch,
        getDurationEnter,
        enterChildren,
        destroy
    });
};
const createAnimatorManager = (node, manager) => {
    switch (manager) {
        case constants_1.ANIMATOR_MANAGER_NAMES.stagger: return createAnimatorManagerStagger(node, constants_1.ANIMATOR_MANAGER_NAMES.stagger);
        case constants_1.ANIMATOR_MANAGER_NAMES.staggerReverse: return createAnimatorManagerStagger(node, constants_1.ANIMATOR_MANAGER_NAMES.staggerReverse);
        case constants_1.ANIMATOR_MANAGER_NAMES.sequence: return createAnimatorManagerSequence(node, constants_1.ANIMATOR_MANAGER_NAMES.sequence);
        case constants_1.ANIMATOR_MANAGER_NAMES.sequenceReverse: return createAnimatorManagerSequence(node, constants_1.ANIMATOR_MANAGER_NAMES.sequenceReverse);
        case constants_1.ANIMATOR_MANAGER_NAMES.switch: return createAnimatorManagerSwitch(node, constants_1.ANIMATOR_MANAGER_NAMES.switch);
        default: return createAnimatorManagerParallel(node, constants_1.ANIMATOR_MANAGER_NAMES.parallel);
    }
};
exports.createAnimatorManager = createAnimatorManager;
