"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderFrameSVGPaths = void 0;
const index_1 = require("../formatFrameSVGPath/index");
const renderFrameSVGPaths = (parentElement, width, height, pathsCustom) => {
    if (width <= 0 || height <= 0) {
        return;
    }
    const pathElementsCurrent = Array.from(parentElement.querySelectorAll('path[data-frame]'));
    for (let index = 0; index < pathsCustom.length; index++) {
        const pathCustom = pathsCustom[index];
        const pathElementCurrent = pathElementsCurrent[index];
        const pathElement = pathElementCurrent !== null && pathElementCurrent !== void 0 ? pathElementCurrent : document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const isCommands = Array.isArray(pathCustom);
        const path = isCommands ? pathCustom : pathCustom.path;
        pathElement.dataset.frame = '';
        Object.assign(pathElement.style, {
            vectorEffect: 'non-scaling-stroke'
        });
        if (!isCommands) {
            const { name, id, className, style } = pathCustom;
            if (pathElement.dataset.name !== name) {
                pathElement.dataset.name = name;
            }
            if (pathElement.id !== id) {
                pathElement.id = id || '';
            }
            if (pathElement.classList.value !== className) {
                pathElement.classList.value = className || '';
            }
            Object.assign(pathElement.style, style);
        }
        pathElement.setAttribute('d', (0, index_1.formatFrameSVGPath)(width, height, path));
        if (pathElement.parentNode !== parentElement) {
            parentElement.appendChild(pathElement);
        }
    }
    // TODO: If the number of polygons change, remove the excess unneeded elements.
};
exports.renderFrameSVGPaths = renderFrameSVGPaths;
